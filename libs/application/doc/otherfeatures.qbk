[/
    Copyright 2013 Renato Tegon Forti
    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
/]



[section:other_features Other Features]

[section Customize Handlers/Callbacks]

The user can customize the default behavior of any handler. To do this, the user needs inheriting of contract handler class (abstract) that he wants to modify the behavior.

For sample: The default behavior of wait_for_termination_request is unblock and exit of application. To change this behavior user can do as follows:

[import ../example/my_own_wait_for_termination_request.cpp]
[mownwfr]


[endsect]

[/
# --------------------------------------------------------------------------------
# customize_signal
# --------------------------------------------------------------------------------
]

[section:customize_signal Customize Signals/Handlers]

Like a handler, the user is free to customize the SIGNALS of application.

[note
The SIGNALS can not be customized when Windows Service (server application mode on windows) is used.

Windows Service uses a completely different set of signals called 'events', so in this case you should customize 'pause', 'resume' and 'stop' handlers
]

This feature allows user configure/add handlers for others SIGNALS.

In this sample we will create a handler to SIGUSR2 POSIX signal. Note that this signal is not available on Windows.

To do this user need inheriting of signal_manager class and add new signal bind, like:

[import ../example/my_own_termination_handler.cpp]
[myownsig]


[endsect]

[section Single Instance Feature] 

Some applications should only have a single instance running on a given operating system, Boost.Application provides a means to easily achieve this, as:

User need define a unique identity to application. To do this the user need generate a [@http://www.boost.org/doc/libs/1_54_0/libs/uuid/ Boost.Uuid].

Optionally, the user can define a callback that will handle if a new instance of application should continue or exit. 

If this callback this is not set the default behavior is terminate. 

[import ../example/limit_single_instance_callback.cpp]
[lsic]

[endsect]


[section Extending Application (Plugin System)]

An important addition of Boost.Application, is a "Shared Library Class" that allow user to extend the application using Dynamic Library Modules (DLL,SO/DSO) loaded at runtime. Using this feature the client can provide a plugin system to application.

[warning 

Unix/Linux Note
To shared library work, on unix/linux variants you need link with: '-ldl' lib (dlopen etc), e.g on bjam: 

<target-os>linux:<linkflags>"-ldl"

]

The class shared_library has a list of methods to load library, find symbol, and get symbol to execution, all of theases methods must be called using a initializer functions (e.g.:'library') that will handle correct string type, and paths. e.g.

```
const boost::filesystem::path shared_library_path("/test/boost/application/libtest_library.so");
shared_library sl(library(shared_library_path));
```

The following diagram shows the process of extension of the application functionality. The library is loaded dynamically in the context of the application, and then a library function is executed. After that, the library is unloaded and will cease to exist in the application.

[$plugin.gif]

Now, a simple tutorial is provided to give you a idea, of how to use shared library class.

The first thing to do is define the plugin interface, this will be a abstract class that will be our plugin API, and we will have a cpp file that will hold a implementation of our plugin.

[import ../example/plugin_api.hpp]
[plugapi]

[import ../example/plugin_library.cpp]
[plugcpp]

Now our application that will use our plugin.

[import ../example/shared_library_load_plugin.cpp]
[callplugcpp]

The output:

[pre
ubuntu@ip-10-248-38-104:./shared_library_load_plugin
Plugin Version: 1
Plugin Method:  3
;o)
]

[endsect]


[/
# --------------------------------------------------------------------------------
# setup_service
# --------------------------------------------------------------------------------
]

[section:setup_service Setup for Windows Service] 

Boost.Application provides a setup code, that can be added to to enable installation/uninstallation of windows service application.

[import ../example/service_setup.cpp]
[wss]

This example shows how to use windows service setup module to provide a installation system to application using program_options.

[pre
[*Installation]
windows_service_setup.exe -i --name "My Service" --path "c:\myservice\service.exe"
windows_service_setup.exe -i --name "My Service" --path "c:\myservice\service.exe" --display "My Service"
windows_service_setup.exe -i --name "My Service" --path "c:\myservice\service.exe" --display "My Service" --description "Service Description"

[*Check Installation]
windows_service_setup.exe -c --name "My Service" 

[*Uninstallation]
windows_service_setup.exe -u --name "My Service" --path "c:\myservice\service.exe" 
]

[important 
Note that you need run this AS ADMIN.
]

[note
Note that when arg name are not priovided, the name will be the name ofexecutable, in thiscase, service name will be: 'windows_service_setup'
]

[endsect]

[endsect]
